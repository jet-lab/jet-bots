import { BN } from '@project-serum/anchor';
import { Market, OpenOrders } from '@project-serum/serum';
import {
  ASSOCIATED_TOKEN_PROGRAM_ID,
  TOKEN_PROGRAM_ID,
} from '@solana/spl-token';
import {
  AccountInfo,
  Connection,
  Keypair,
  PublicKey,
  sendAndConfirmTransaction,
  Transaction,
  TransactionInstruction,
} from '@solana/web3.js';

/*
export async function findOpenOrdersAccounts(
  connection: Connection,
  market: PublicKey,
  owner: PublicKey,
  programId: PublicKey,
): Promise<PublicKey[]> {
  const filters = [
    {
      memcmp: {
        offset: OpenOrders.getLayout(programId).offsetOf('market'),
        bytes: market.toBase58(),
      },
    },
    {
      memcmp: {
        offset: OpenOrders.getLayout(programId).offsetOf('owner'),
        bytes: owner.toBase58(),
      },
    },
    {
      dataSize: OpenOrders.getLayout(programId).span,
    },
  ];
  const accounts = await getFilteredProgramAccounts(
    connection,
    programId,
    filters,
  );
  return accounts.map(({ publicKey }) =>
    publicKey,
  );
}

export async function getAssociatedTokenAddress(
  mint: PublicKey,
  owner: PublicKey,
): Promise<PublicKey> {
  return (await PublicKey.findProgramAddress(
    [
      owner.toBuffer(),
      TOKEN_PROGRAM_ID.toBuffer(),
      mint.toBuffer(),
    ],
    ASSOCIATED_TOKEN_PROGRAM_ID,
  ))[0];
}

async function getFilteredProgramAccounts(
  connection: Connection,
  programId: PublicKey,
  filters,
): Promise<{ publicKey: PublicKey; accountInfo: AccountInfo<Buffer> }[]> {
  // @ts-ignore
  const resp = await connection._rpcRequest('getProgramAccounts', [
    programId.toBase58(),
    {
      commitment: connection.commitment,
      filters,
      encoding: 'base64',
    },
  ]);
  if (resp.error) {
    throw new Error(resp.error.message);
  }
  return resp.result.map(
    ({ pubkey, account: { data, executable, owner, lamports } }) => ({
      publicKey: new PublicKey(pubkey),
      accountInfo: {
        data: Buffer.from(data[0], 'base64'),
        executable,
        owner: new PublicKey(owner),
        lamports,
      },
    }),
  );
}

export function getSplTokenBalanceFromAccountInfo(
  accountInfo: AccountInfo<Buffer>,
  decimals: number,
): number {
  return divideBnToNumber(
    new BN(accountInfo.data.slice(64, 72), 10, 'le'),
    new BN(10).pow(new BN(decimals)),
  );
}

export async function getVaultOwnerAndNonce(publicKey: PublicKey, programId: PublicKey) {
  const nonce = new BN(0);
  while (nonce.toNumber() < 255) {
    try {
      const vaultOwner = await PublicKey.createProgramAddress(
        [publicKey.toBuffer(), nonce.toArrayLike(Buffer, "le", 8)],
        programId
      );
      return [vaultOwner, nonce];
    } catch (e) {
      nonce.iaddn(1);
    }
  }
  throw new Error("Unable to find nonce");
}

export function sleep(ms: number) {
  return new Promise( resolve => setTimeout(resolve, ms) );
}
*/
